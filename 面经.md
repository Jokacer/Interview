### tx
#### IEG一面：
1. c++内存堆和栈的区别：
   | |管理方式|扩展方向|存储内容|空间大小|碎片|
   |--|--|--|--|--|--|
   |栈|系统自动开辟空间，自动分配自动回收，在作用域运行完成后（函数返回时）就会被回收|高位向地位扩展|存储自动变量，调用者信息，局部变量，函数返回值|1M或2M|系统自动管理，没有碎片|
   |堆|由程序员自己申请空间，释放空间，不释放会出现内存泄漏|由地位向高位扩展|malloc手动申请的空间|32位系统内有4G|空间不断申请和释放是产生碎片|
2. linux指令：
   1. 查看内存的指令：free
   2. 查看cpu使用率等：top（如何得到的：通过访问/proc/stat中的数据计算而得）
   3. 创建文件夹：mkdir
3. 算法：小Q有X首长度为A的不同的歌和Y首长度为B的不同的歌，现在小Q想用这些歌组成一个总长度正好为K的歌单，每首歌最多只能在歌单中出现一次，在不考虑歌单内歌曲的先后顺序的情况下，请问有多少种组成歌单的方法。（背包问题）
4. tcp三次握手：
   1. 第一次S知道C的发送能力和自己的接受能力
   2. 第二次c知道自己的发送能力、自己的接受能力，对方的接受能力和发送能力
   3. 第三次服务器知道自己的发送能力和对方的接受能力
5. tcp和udp区别
6. c++返回局部变量的指针会怎么样：返回肯定是可以返回的，只是返回的指针不马上使用所指向的内容就可能被修改，平时返回值比如返回一个int a其实是返回的拷贝
7. 数据库添加一列：ALTER TABLE table_name ADD column_name datatype
8. 有十亿个用户，可能在线可能不在线，如何判断某个用户是否在线：用位存储，没有用户对应一个比特位，在线为1不在线为0


#### cdg？一面：
1. 写个快排：
```c
void quicksort(int a[],int left,int right)
{
    int i,j,temp;
    i=left;
    j=right;
    temp=a[left];
    if(left>right)
        return;
    while(i!=j)
    {
        while(a[j]>=temp&&j>i)
            j--;
        if(j>i)
            a[i++]=a[j];
        while(a[i]<=temp&&j>i)
            i++;
        if(j>i)
            a[j--]=a[i];
         
    }
    a[i]=temp;
    quicksort(a,left,i-1);
    quicksort(a,i+1,right);
}
```
2. 数组去重：比如把abbcc变成abc
3. 一亿个数求top n（利用快排）
4. epoll和select：
   1. select每次调用都将fd集合从用户态拷贝到内核态，每次调用都需要在内核中遍历所有的fd，select支持的文件描述符太小默认1024，poll没有限制
   2. epool用红黑树存储fd，每次通过epoll_ctl将fd加入到内核同时通过双向列表来返回已经触发某一个事件的fd
5. tcp和udp区别：
  1. 基于连接与无连接
  2. TCP要求系统资源较多，UDP较少； 
  3. UDP程序结构较简单 
  4. 流模式（TCP）与数据报模式(UDP); 
  5. TCP保证数据正确性，UDP可能丢包 
  6. TCP保证数据顺序，UDP不保证 
6. 数据库事务的隔离级别：mysql提供四种，默认是2，Oracle只支持1和3
   1. Serializable (串行化)：可避免脏读、不可重复读、幻读的发生
   2. Repeatable read (可重复读)：可避免脏读、不可重复读的发生。
   3. Read committed (读已提交)：可避免脏读的发生。
   4. Read uncommitted (读未提交)：最低级别，任何情况都无法保证。
7. 指针和引用的区别：
   1. 指针：指针是一个变量，只不过这个变量存储的是一个地址，指向内存的一个存储单元；而引用跟原来的变量实质上是同一个东西，只不过是原变量的一个别名而已
   2. 引用不可以为空，当被创建的时候，必须初始化，而指针可以是空值，可以在任何时候被初始化。
   3. 指针可以有多级，但是引用只能是一级（int **p；合法 而 int &&a是不合法的）
   4. 指针的值在初始化后可以改变，即指向其它的存储单元，而引用在进行初始化后就不会再改变了
   5. 如果返回动态内存分配的对象或者内存，必须使用指针，引用可能引起内存泄漏
   6. 引用作为函数参数进行传递时，实质上传递的是实参本身，即传递进来的不是实参的一个拷贝
   7. 指针作为参数进行传递时，事实上也是值传递，只不过传递的是地址。当把指针作为参数进行传递时，也是将实参的一个拷贝传递给形参